### **LCP 01-10**

#### [LCP 01. 猜数字](https://leetcode-cn.com/problems/guess-numbers/)

题：小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？

输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。

示例：

```markdown
输入：guess = [1,2,3], answer = [1,2,3]
输出：3
```

解释：小A 每次都猜对了。

```js
/**
 * @param {number[]} guess
 * @param {number[]} answer
 * @return {number}
 */
var game = function(guess, answer) {
    let count = 0;
    for (let i=0; i<guess.length; i++) {
        if (answer[i] == guess[i]) {
            count++;
        }
    }
    return count;
};
```

#### [LCP 02. 分式化简](https://leetcode-cn.com/problems/deep-dark-fraction/)

题：有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？

![fraction_example_1](https://github.com/xingwy/Algorithm/tree/master/images/fraction_example_1.jpg)

连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。

输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。

示例：

```markdown
输入：cont = [3, 2, 0, 2]
输出：[13, 4]
```

解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。

```js
/**
 * @param {number[]} cont
 * @return {number[]}
 */
var fraction = function(cont) {
    let dfs = function(index) {
        if (index == cont.length-1) {
            return [1, cont[index]]
        } else {
            let d = dfs(index+1);
            return [d[1], d[0] + cont[index]*d[1]];
        }
    }

    let gcd = function(a, b) {
        let mod = a%b;
        if (mod == 0) {
            return b;
        } else {
            return gcd(b, mod)
        }
    }
    let v = dfs(0);
    let mod = gcd(Math.max(...v), Math.min(...v));
    return [v[1]/mod, v[0]/mod];
};
```

#### [LCP 03. 机器人大冒险](https://leetcode-cn.com/problems/programmable-robot/)

题：力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：

1. U: 向y轴正方向移动一格

2. R: 向x轴正方向移动一格。


不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。

给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。

示例：

```markdown
输入：command = "URR", obstacles = [], x = 3, y = 2
输出：true
```

解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。

```js
/**
 * @param {string} command
 * @param {number[][]} obstacles
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
var robot = function(command, obstacles, x, y) {
    // 计算一个轮回走的点位置
    let canArrive = new Set();
    let Y = 0; 
    let X = 0;
    canArrive.add([0,0].toString());
    for (let i=0; i<command.length; i++) {
        if (command[i] == "U") {
            Y++;
        } else if (command[i] == "R") {
            X++;
        }
        canArrive.add([X,Y].toString());
    }
    {
        let mod_x = Math.floor(x/X);
        let mod_y = Math.floor(y/Y);
        let mod_m = Math.min(mod_x, mod_y);
        if (!canArrive.has([x - X*mod_m, y-Y*mod_m].toString())) {
            return false;
        }
    }
    obstacles = obstacles.filter((v) => {
        if(v[0] <= x && v[1] <= y && v[0] >= 0 && v[1] >= 0) {
            return true
        }
        return false;
    }).map((v) => {
        let mod_x = Math.floor(v[0]/X);
        let mod_y = Math.floor(v[1]/Y);
        let mod_m = Math.min(mod_x, mod_y);
        return [v[0] - X*mod_m, v[1]-Y*mod_m];
    })
    for (let i=0; i<obstacles.length; i++) {
        if (canArrive.has(obstacles[i].toString())) {
            return false;
        }
    }
    return true;
};
```

