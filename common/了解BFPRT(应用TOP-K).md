### **TOP-K问题**

需求描述：在一大堆数(数量n)中求其前k大或前k小的问题，简称TOP-K问题。

方案一：最方便的方法就是排序，然后取前k个数。时间复杂度：O(nlogn)

方法二：方案一是对所有元素进行排序，其实对于求前K值，不需要排序整体，只需构建前K个数值即可。那可以构建容量为K最大/最小堆。对于每一个元素，维护堆的代价为O(K)，总消耗变更为O(nlogk);

方法三：另一种思路，借助快排的思想。

快排的每次划分，小于等于分界值 `pivot` 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。对于每次pivot，pos是分界线的序号序号，它将此区间分解成了left和right，那么有以下几种情况：

- k == pos+left，此刻，pos就是分界线
- k < pos + left，那么说明结果k在pos左侧，在left区间，继续递归求解left区间。
- k > pos + left，那么说明结果k在pos右侧，在right区间，继续递归求解right区间。

那怎么求证复杂度？

假设每次的区间分割都能使区间一分为二，那么最终理想的分割需要logn次，记为m。设整体期望复杂度为F(n)

对于第i次分割，所需要的消耗的次数趋于n*(1^2)^i（i∈[1,m]），f(n) = n * (1/2) + n * (1/4) + ··· + n * (1/2)^m,

抽出n，f(n)=n*g(m)，g(m)为底数为1/2的等比数列的前m项和，所以f(n) <= n，所以可以计算出期望复杂度为 O(n)。

但之前的假设是，每次能将区间分割为2份相同长度的区间，那么最快的情况呢？情况最差时，每次的划分点都是最大值或最小值，一共需要划分 n - 1*n*−1 次，而一次划分需要线性的时间复杂度，所以最坏情况下时间复杂度为O(n^2)。

方法四：方法三的最坏或较坏情况，源于选取分界值时的不确定因素。那如何通过一个好的方式去选取一个分界值去做区间划分呢？

能将区间平分为二份的，那么中位数作为分界值将是一个好选择。（或接近中位数的值）

如果将每个元素当做一组，即有n组，很显然，这种情况求中位数（假设需要消耗O(n)）,很显然能定位到n/2的元素比中位数小。（第i次定位需要消耗n*(1^2)^i）

下面换个思路：方法一是将一个元素作为一组，那么扩展这个组的个数呢？

设p为组的元素个数，那么操作将会变成如下步骤：

- a：选取中位数节点
  - ① 将n个元素划分为n/p组，每组p个元素
  - ② 定位到p个元素组的中位数节点
  - ③ 步骤②中求出的中位数节点，继续用此方法求出中位数（n/p个中位数节点中的中位数）。
- b：步骤③中选取的中位数，按照此为标准，大于中位数的中位数节点放右边，小于则放左边（快排思路）
- c：用步骤③选取的中位数位置与k进行判断，计算k的相对位置，或递归操作。

时间复杂度如何分析？

未完待续