### **缓存算法**

[原题](https://leetcode-cn.com/problems/lfu-cache)：实现 LFUCache 类：

- LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象

- get(K key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。

- put(K key, T value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最久未使用 的键。

注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

在设计之前先了解下LFU算法，最近最少使用算法，如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。设计到的操作有以下两个：

- set(key, put)；将记录(key,value)插入该结构。当缓存满时，将最久未使用的数据置换掉，同上put；
- get(key)；获取对应key值；

考虑到LFU会淘汰访问频率最小的数据，设计思路就是维护一个以访问频率为K的TOP K问题。很容易想到的就是二项堆。不过，由于二项堆的删除性能瓶颈，这个方法对于时间性能并不是最佳的，我们讨论另一种，使用双哈希表来记录数据。

表1：内存地址和原数据的映射

表2：频率和同频率数据集合的映射

设key_table为表1，times_table为表2

对于get(k)操作：

- 检测key_table是否存在k
- k对应node的time_node+1
- 将node从times_table中time_node位置移到time_node+1位置，并置于链表首。
- 返回值，结束。

对于set(k)操作

- 缓存满
  - 检测最小次数，并删除times_table中最小末尾节点。
  - 插入此节点

太懒了，代码就不写了

